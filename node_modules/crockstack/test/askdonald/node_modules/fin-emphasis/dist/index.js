"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dict = require("./dictionary");
const Fin = require("finnlp");
Fin.Run.prototype.emphasis = function () {
    const result = [];
    this.sentences.forEach((sentence, sentenceIndex) => {
        result[sentenceIndex] = [];
        sentence.tokens.forEach((token, tokenIndex) => {
            result[sentenceIndex][tokenIndex] = 1;
        });
    });
    this.sentences.forEach((sentence, sentenceIndex) => {
        const tags = sentence.tags;
        tags.forEach((tag, tagIndex) => {
            if (tag === "JJS")
                result[sentenceIndex][tagIndex]++;
            else if (tag === "RBS")
                result[sentenceIndex][tagIndex]++;
        });
        const tokens = sentence.tokens;
        tokens.forEach((token, tokenIndex) => {
            const score = dict.adverbsOfEmphasis[token.toLowerCase()];
            if (score) {
                const nearestParent = findTarget(tokenIndex, sentence);
                result[sentenceIndex][nearestParent] = result[sentenceIndex][nearestParent] + score;
            }
        });
    });
    return result;
};
function nextTag(index, sentence, test, distance) {
    return sentence.tags.findIndex((tag, i) => {
        return i > index && (i - index) < distance + 1 && test.test(tag);
    });
}
function findTarget(tokenIndex, sentence) {
    const parent = sentence.deps[tokenIndex].parent;
    const closestNeighbor = [
        nextTag(tokenIndex, sentence, /N/, 1),
        nextTag(tokenIndex, sentence, /C/, 1),
        nextTag(tokenIndex, sentence, /J/, 1),
        nextTag(tokenIndex, sentence, /N/, 2),
        nextTag(tokenIndex, sentence, /C/, 2),
        nextTag(tokenIndex, sentence, /J/, 2),
    ]
        .find(x => x !== -1);
    if (closestNeighbor !== undefined && closestNeighbor !== -1)
        return closestNeighbor;
    else if (parent === -1)
        return tokenIndex;
    else
        return parent;
}
